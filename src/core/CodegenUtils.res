// SPDX-License-Identifier: MPL-2.0

// CodegenUtils.res - Utility functions for code generation

// Convert a string to PascalCase
@module("@std/text") external toPascalCase: string => string = "toPascalCase"

// Convert a string to camelCase
@module("@std/text") external toCamelCase: string => string = "toCamelCase"

// Sanitize identifier (remove special characters, ensure valid ReScript identifier)
let sanitizeIdentifier = (str: string): string =>
  str
  ->String.replaceAll("{", "")->String.replaceAll("}", "")
  ->String.replaceAll("[", "")->String.replaceAll("]", "")
  ->String.replaceAll(".", "_")->String.replaceAll("-", "_")
  ->String.replaceAll("/", "_")->String.replaceAll(" ", "_")

// Generate type name from path and method
let generateTypeName = (~prefix="", path: string, suffix: string): string => {
  let cleaned = path
    ->String.replaceAll("/", "_")
    ->sanitizeIdentifier
    ->String.split("_")
    ->Array.filter(part => part != "")
    ->Array.map(toPascalCase)
    ->Array.join("")
  
  prefix ++ cleaned ++ suffix
}

// Generate operation name from operationId or path + method
let generateOperationName = (operationId: option<string>, path: string, method: string): string =>
  switch operationId {
  | Some(id) => toCamelCase(sanitizeIdentifier(id))
  | None =>
      method->String.toLowerCase ++ path
        ->String.split("/")
        ->Array.filter(part => part != "" && !(part->String.startsWith("{")))
        ->Array.map(toCamelCase)
        ->Array.join("")
  }

// Escape ReScript string
let escapeString = (str: string): string =>
  str
  ->String.replaceAll("\\", "\\\\")->String.replaceAll("\"", "\\\"")
  ->String.replaceAll("\n", "\\n")->String.replaceAll("\r", "\\r")
  ->String.replaceAll("\t", "\\t")

// Generate file header
let generateFileHeader = (~description: string): string =>
  `// ${description}
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

`

// Indent code
let indent = (code: string, level: int): string => {
  let spaces = "  "->String.repeat(level)
  code
  ->String.split("\n")
  ->Array.map(line => line->String.trim == "" ? "" : spaces ++ line)
  ->Array.join("\n")
}

/**
 * Removes leading whitespace followed by a margin prefix from every line of a string.
 * This is useful for writing multiline templates in a more readable way.
 */
let trimMargin = (text: string, ~marginPrefix="|") => {
  text
  ->String.split("\n")
  ->Array.map(line => {
    let trimmed = line->String.trimStart
    if trimmed->String.startsWith(marginPrefix) {
      trimmed->String.slice(~start=String.length(marginPrefix))
    } else {
      line
    }
  })
  ->Array.join("\n")
  ->String.trim
}

// ReScript keywords that need to be escaped
let rescriptKeywords = [
  "and", "as", "assert", "async", "await", "catch", "class", "constraint",
  "do", "done", "downto", "else", "end", "exception", "external", "false",
  "for", "fun", "function", "functor", "if", "in", "include", "inherit",
  "initializer", "lazy", "let", "method", "module", "mutable", "new",
  "nonrec", "object", "of", "open", "or", "private", "rec", "sig", "struct",
  "switch", "then", "to", "true", "try", "type", "val", "virtual", "when",
  "while", "with"
]

// Escape ReScript keywords by adding underscore suffix
let escapeKeyword = (name: string): string => rescriptKeywords->Array.includes(name) ? name ++ "_" : name

// Generate documentation comment (single-line comments)
let generateDocComment = (~summary=?, ~description=?, ()): string =>
  switch (summary, description) {
  | (None, None) => ""
  | (Some(s), None) => `// ${s}\n`
  | (None, Some(d)) => `// ${d}\n`
  | (Some(s), Some(d)) => `// ${s}\n// ${d}\n`
  }

// Generate DocString comment (multi-line /** ... */ format) from markdown
let generateDocString = (~summary=?, ~description=?, ()): string => {
  let content = switch (summary, description) {
  | (None, None) => None
  | (Some(s), None) => Some(s)
  | (None, Some(d)) => Some(d)
  | (Some(s), Some(d)) => Some(s == d ? s : s ++ "\n\n" ++ d)
  }
  
  content->Option.map(text => {
    let lines = text->String.trim->String.split("\n")->Array.map(String.trim)
    switch lines {
    | [] => ""
    | [line] => `/** ${line} */\n`
    | lines => "/**\n" ++ lines->Array.map(l => l == "" ? " *" : ` * ${l}`)->Array.join("\n") ++ "\n */\n"
    }
  })->Option.getOr("")
}

// Shared type signature for the fetch function used in generated code
let fetchTypeSignature = "(~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>"
