// SPDX-License-Identifier: MPL-2.0

// Templates.res - All Handlebars templates in one place

// === CodegenUtils ===

let fileHeader = `// {{{description}}}
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()
`

let docCommentSingle = `/** {{{content}}} */
`

let docCommentMulti = `/**
{{#each lines}}{{{this}}}
{{/each}}*/
`

let docComment = `{{#if summary}}// {{{summary}}}
{{/if}}{{#if description}}// {{{description}}}
{{/if}}`

// === EndpointGenerator ===

let endpointFunction = `{{{docComment}}}let {{{functionName}}} = async ({{{bodyParam}}}{{{paramSep}}}~fetch: {{{fetchTypeSignature}}}): {{{functionName}}}Response => {
{{{bodyValueConversion}}}
  let response = await fetch(
    ~url="{{{path}}}",
    ~method_="{{{methodUpper}}}",
    ~body={{{bodyArg}}},
  )
{{{responseHandling}}}
}`

let moduleWrapped = `{{{header}}}

module {{{moduleName}}} = {
{{{body}}}
}`

let moduleUnwrapped = `{{{header}}}

{{{body}}}`

// === ModuleGenerator ===

let indexModule = `{{{header}}}

module {{{moduleName}}} = {
{{#each tags}}  module {{{modulePascal}}} = {{{modulePascal}}}
{{/each}}}`

let combinedModule = `{{{header}}}

{{{shared}}}

{{{extension}}}`

// === ThinWrapperGenerator ===

let clientType = `type client = {
  baseUrl: string,
  token: option<string>,
  fetch: {{{fetchTypeSignature}}},
}`

let connectFunction = `/** Create a client for {{{title}}} */
let connect = (~baseUrl: string, ~token: option<string>=?, ~fetch: {{{fetchTypeSignature}}}, ()): client => {
  baseUrl,
  token,
  fetch,
}`

let wrapperFunction = `{{{docComment}}}  {{{signature}}}: promise<{{{generatedModuleName}}}.{{{operationName}}}Response> => 
    {{{generatedModuleName}}}.{{{operationName}}}({{{callArguments}}}~fetch=client.fetch)`

let wrapperFile = `// Generated thin wrapper

{{{clientTypeCode}}}

{{{connectFunctionCode}}}

{{{modulesCode}}}`

// === TypeScriptDtsGenerator ===

let methodSignature = `{{{docLines}}}
  {{{functionName}}}({{{params}}}): Promise<{{{responsePascalName}}}Response>;`

let moduleDts = `// TypeScript definitions for {{{moduleName}}}
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT

import { MisskeyClient } from './index';
import * as ComponentSchemas from './ComponentSchemas';

{{{interfaces}}}

export interface {{{moduleName}}}Module {
{{{methodSignatures}}}
}

export const {{{moduleName}}}: {{{moduleName}}}Module;`

let componentSchemasDts = `// TypeScript definitions for ComponentSchemas
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT

{{{content}}}`

let indexDts = `// TypeScript definitions
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT

{{#each modules}}{{{importLine}}}
{{/each}}
export class MisskeyClient {
  constructor(baseUrl: string, token?: string);
  readonly baseUrl: string;
  readonly token?: string;
}

{{#each modules}}{{{exportLine}}}
{{/each}}`

// === TypeScriptWrapperGenerator ===

let wrapperMjsMethod = `  async {{{functionName}}}(client{{{requestArg}}}) {
    return {{{moduleName}}}.{{{functionName}}}({
      {{{bodyArg}}}fetch: (url, method, body) => client._fetch(url, method, body)
    });
  },`

let wrapperMjsNamespace = `export const {{{moduleName}}} = {
{{{methods}}}
};`

let wrapperMjs = `// Generated wrapper
{{#each tags}}{{{importLine}}}
{{/each}}
{{{clientCode}}}

{{#each tags}}{{{namespace}}}

{{/each}}`

let wrapperDtsFunction = `{{{docComment}}}  export function {{{functionName}}}(client: MisskeyClient{{{requestParam}}}): Promise<{{{pascalName}}}Response>;`

let wrapperDtsNamespace = `export namespace {{{moduleName}}} {
{{{functions}}}
}`

let wrapperDts = `// Generated TypeScript definitions for wrapper
{{#each tags}}{{{importBlock}}}
{{/each}}
export class MisskeyClient {
  constructor(baseUrl: string, token?: string);
  readonly baseUrl: string;
  readonly token?: string;
}

{{#each tags}}{{{namespace}}}

{{/each}}`

// === DiffReportGenerator ===

let mergeReport = `# Merge Report: {{{baseName}}} + {{{forkName}}}

## Shared Code

- **Shared Endpoints**: {{{sharedEndpoints}}}
- **Shared Schemas**: {{{sharedSchemas}}}

## {{{forkName}}} Extensions

- **Extension Endpoints**: {{{extensionEndpoints}}}
- **Extension Schemas**: {{{extensionSchemas}}}

## Summary

The shared base contains {{{sharedEndpoints}}} endpoints and {{{sharedSchemas}}} schemas.

{{{forkName}}} adds {{{extensionEndpoints}}} endpoints and {{{extensionSchemas}}} schemas.

---
*Generated on {{{timestamp}}}*`

// === SchemaCodeGenerator ===

let endpointModule = `{{{docComment}}}module {{{moduleName}}} = {
{{{schemasCode}}}

  let endpoint = "{{{path}}}"
  let method = #{{{methodStr}}}
}`

// === DocOverride ===

let overrideMarkdown = `{{{metadataBlock}}}

# {{{title}}}

**Path**: \`{{{path}}}\`  
**Method**: \`{{{methodUpper}}}\`  
**Operation**: \`{{{operationName}}}\`

## Default Description

{{{defaultDesc}}}

## Override

Add your custom documentation here. If this code block is empty, the default description will be used.

\`\`\`
<!-- Empty - no override -->
\`\`\``

let overrideReadme = `# API Documentation Overrides

This directory contains markdown files that allow you to override the auto-generated documentation.

## Global Information

- **Host**: {{{hostInfo}}}
- **Version**: {{{versionInfo}}}

## Structure

Each module has its own directory, and each endpoint has its own markdown file:

\`\`\`
docs/
├── README.md (this file)
├── Account/
│   ├── postBlockingCreate.md
│   ├── postBlockingDelete.md
│   └── ...
├── Notes/
│   ├── postNotesCreate.md
│   └── ...
└── ...
\`\`\`

## How to Override

1. Find the endpoint you want to document in its module directory
2. Open the markdown file
3. Edit the code block under the "## Override" section
4. Add your custom documentation (supports markdown)
5. Regenerate the code - your custom documentation will be used instead of the default

## File Format

Each file contains:

### Frontmatter
- \`endpoint\`: The API endpoint path
- \`method\`: HTTP method (GET, POST, etc.)
- \`hash\`: Hash of the endpoint for change detection
- \`host\`: API host URL
- \`version\`: API version
- \`operationId\`: OpenAPI operation ID

### Default Description
The original description from the OpenAPI spec.

### Override Section
A code block where you can add your custom documentation. If empty, the default description is used.

## Example

\`\`\`markdown
---
endpoint: /blocking/create
method: POST
hash: abc123
host: https://misskey.io
version: 1.0.0
---

# blocking/create

**Path**: \`/blocking/create\`
**Method**: \`POST\`

## Default Description

No description provided.

**Credential required**: *Yes* / **Permission**: *write:blocks*

## Override

\`\`\`
Create a blocking relationship with another user.

This endpoint allows you to block a user by their user ID. Once blocked:
- The user will not be able to see your posts
- You will not see their posts in your timeline
- They cannot follow you

**Parameters:**
- \`userId\`: The ID of the user to block

**Example:**
\`\`\`typescript
await client.blocking.create({ userId: "user123" })
\`\`\`
\`\`\`
\`\`\`

## Notes

- The hash is used to detect if the endpoint has changed in the OpenAPI spec
- If the endpoint changes, you may need to update your override
- Empty override blocks (with just \`<!-- Empty - no override -->\`) are ignored`

// === ComponentSchemaGenerator ===

let componentSchemaModule = `{{{docComment}}}module {{{moduleName}}} = {
{{{extractedBlock}}}{{{typeKeyword}}} = {{{typeCode}}}
  let schema = {{{schemaCode}}}
}`
