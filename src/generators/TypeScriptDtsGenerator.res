// SPDX-License-Identifier: MPL-2.0

// TypeScriptDtsGenerator.res - Generate TypeScript .d.ts definition files
open Types

let getFirstJsonSchema = (contentDict: dict<mediaType>): option<jsonSchema> =>
  Dict.keysToArray(contentDict)
  ->Array.get(0)
  ->Option.flatMap(contentType => Dict.get(contentDict, contentType))
  ->Option.flatMap(mediaType => mediaType.schema)

let generateTypeScriptType = (name, description, schema) => {
  let (irType, _) = SchemaIRParser.parseJsonSchema(schema)
  IRToTypeScriptGenerator.generateNamedType(~namedSchema={name, description, type_: irType})
}

// Generate TypeScript interface for request type
let generateRequestInterface = (~endpoint: endpoint, ~functionName) => {
  let requestTypeName = `${CodegenUtils.toPascalCase(functionName)}Request`
  endpoint.requestBody->Option.flatMap(body =>
    getFirstJsonSchema(body.content)->Option.map(schema =>
      generateTypeScriptType(requestTypeName, body.description, schema)
    )
  )
}

// Generate TypeScript interface for response type
let generateResponseInterface = (~endpoint: endpoint, ~functionName) => {
  let responseTypeName = `${CodegenUtils.toPascalCase(functionName)}Response`
  let successCodes = ["200", "201", "202", "204"]
  let successResponse = successCodes
    ->Array.filterMap(code => Dict.get(endpoint.responses, code))
    ->Array.get(0)

  successResponse
  ->Option.flatMap(response =>
    response.content
    ->Option.flatMap(getFirstJsonSchema)
    ->Option.map(schema => generateTypeScriptType(responseTypeName, response.description->Some, schema))
  )
  ->Option.getOr(`export type ${responseTypeName} = void;`)
}

// Generate method signature for endpoint in an interface
let generateMethodSignature = (~endpoint: endpoint, ~functionName) => {
  let params = endpoint.requestBody->Option.isSome
    ? `client: MisskeyClient, request: ${CodegenUtils.toPascalCase(functionName)}Request`
    : "client: MisskeyClient"

  let docLines = endpoint.summary->Option.mapOr([], summary => {
    let lines = ["  /**", `   * ${summary}`]
    endpoint.description->Option.forEach(description => {
      if description != summary {
        lines->Array.push(`   * ${description}`)
      }
    })
    lines->Array.push("   */")
    lines
  })

  let code = `
    |${docLines->Array.join("\n")}
    |  ${functionName}(${params}): Promise<${CodegenUtils.toPascalCase(functionName)}Response>;`
  
  code->CodegenUtils.trimMargin
}

// Generate .d.ts file for a module (grouped by tag)
let generateModuleDts = (~moduleName, ~endpoints: array<endpoint>) => {
  let interfaces =
    endpoints
    ->Array.map(endpoint => {
      let functionName = CodegenUtils.generateOperationName(
        endpoint.operationId,
        endpoint.path,
        endpoint.method,
      )
      let requestPart =
        generateRequestInterface(~endpoint, ~functionName)->Option.getOr("")
      let responsePart = generateResponseInterface(~endpoint, ~functionName)
      [requestPart, responsePart]->Array.filter(s => s != "")->Array.join("\n")
    })
    ->Array.join("\n\n")

  let methodSignatures =
    endpoints
    ->Array.map(endpoint =>
      generateMethodSignature(
        ~endpoint,
        ~functionName=CodegenUtils.generateOperationName(
          endpoint.operationId,
          endpoint.path,
          endpoint.method,
        ),
      )
    )
    ->Array.join("\n")

  let header = `
    |// TypeScript definitions for ${moduleName}
    |// Generated by @f3liz/rescript-autogen-openapi
    |// DO NOT EDIT
    |
    |import { MisskeyClient } from './index';
    |import * as ComponentSchemas from './ComponentSchemas';
    |`->CodegenUtils.trimMargin

  `
    |${header}
    |
    |${interfaces}
    |
    |export interface ${moduleName}Module {
    |${methodSignatures}
    |}
    |
    |export const ${moduleName}: ${moduleName}Module;
    |`->CodegenUtils.trimMargin
}

// Generate ComponentSchemas.d.ts
let generateComponentSchemasDts = (~schemas: Dict.t<jsonSchema>) => {
  let content =
    Dict.toArray(schemas)
    ->Array.map(((name, schema)) => generateTypeScriptType(name, schema.description, schema))
    ->Array.join("\n\n")

  `
    |// TypeScript definitions for ComponentSchemas
    |// Generated by @f3liz/rescript-autogen-openapi
    |// DO NOT EDIT
    |
    |${content}
    |`->CodegenUtils.trimMargin
}

// Generate main index.d.ts with MisskeyClient class
let generateIndexDts = (~moduleNames) => {
  let imports = moduleNames->Array.map(m => `import { ${m}Module } from './${m}';`)->Array.join("\n")
  let exports = moduleNames->Array.map(m => `export const ${m}: ${m}Module;`)->Array.join("\n")

  `
    |// TypeScript definitions
    |// Generated by @f3liz/rescript-autogen-openapi
    |// DO NOT EDIT
    |
    |${imports}
    |
    |export class MisskeyClient {
    |  constructor(baseUrl: string, token?: string);
    |  readonly baseUrl: string;
    |  readonly token?: string;
    |}
    |
    |${exports}
    |`->CodegenUtils.trimMargin
}

// Generate all .d.ts files for a spec
let generate = (~spec: openAPISpec, ~endpoints, ~outputDir): Pipeline.generationOutput => {
  let endpointsByTag = OpenAPIParser.groupByTag(endpoints)
  let moduleNames = []
  let files =
    Dict.toArray(endpointsByTag)
    ->Array.filterMap(((tag, tagEndpoints)) =>
      if Array.length(tagEndpoints) > 0 {
        let name = CodegenUtils.toPascalCase(tag)
        moduleNames->Array.push(name)
        Some({
          FileSystem.path: FileSystem.makePath(outputDir, `types/${name}.d.ts`),
          content: generateModuleDts(~moduleName=name, ~endpoints=tagEndpoints),
        })
      } else {
        None
      }
    )

  spec.components
  ->Option.flatMap(c => c.schemas)
  ->Option.forEach(schemas =>
    files->Array.push({
      path: FileSystem.makePath(outputDir, "types/ComponentSchemas.d.ts"),
      content: generateComponentSchemasDts(~schemas=schemas),
    })
  )

  files->Array.push({
    path: FileSystem.makePath(outputDir, "types/index.d.ts"),
    content: generateIndexDts(~moduleNames),
  })

  {files, warnings: []}
}